#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <climits>
#include <array>
#include "stdio.h"

std::ifstream myFile;
std::string line;
// double EKGData; // most MIT BIH data seems to be 650k samples long. I'm not sure why, but if I declare this inside main, I get what appears to be a memory address error. Clearing up space on my HDD didn't affect anything, but reducing the size of the array allocation inside the function, or just putting the declaration outside the function like I did here seems to clear the error. I'm declaring this as a double because according to Prof Spano, most computers do their math in double by default. Even if you declare this as a float, which is smaller, your computer will first convert it to a double, do the math, then go back to float - which ends up taking longer.
// EKGData = (double *) calloc (100, siezof(int)); // not working

int getFileSize(std::ifstream& myFile) {
    int lineLength = 0;
    std::string line;
    while(getline(myFile,line))
    {
        lineLength++;
    }
    
    return lineLength;
}

int main(int argc, const char * argv[])
{
    double EKGData[650000][2];
    std::string inputFile = "MITBIH100fullData.txt"; // I'm doing all this nasty file delimiting in main and not a separate function because I can't return arrays in C++ without some ridiculous legwork.
    std::string tempString; // holds a 'number' while file is being parsed
    myFile.open(inputFile);

    // this next while loop finds the size of the file first. When I tried to implement this in its own function, I get a "call to implicitly-deleted copy constructor" error, which I was unable to troubleshoot. So this is directly implemented in main as well.

    
    if (myFile.is_open())
    {
        int j = 0; // used to track columns in EKGData array
        int k = 0; // used to track rows in EKGData array
        while (getline(myFile, line)) // while the file has more content
        {
            j = 0;
            for(int i = 0; i < line.size(); i++)
            {
                // bool eval = (line[i] == ','); // for debugging
                // bool eval2 = (i == line.size() - 1); // for debugging
                switch (line[i] == ',' || i == line.size() - 1) // manual delimiting
                {
                    case 0: // no comma, keep writing
                        std::cout << line[i];
                        tempString.push_back(line[i]);
                        break; // switch cases have to break in C++ 
                    case 1: // comma present, write the first set of data
                        //std::sscanf(tempString.data(), "%f", &(EKGData[i][j])); // write the temp string
                        //std::sscanf(tempString.c_str(), "%f", &(EKGData[i][j])); // write the temp string
                        std::sscanf(tempString.data(), "%lf", &(EKGData[k][j])); // write the temp string
                        tempString = ""; // clear the temp string
                        j++; // move to next column
                        break;
                    default:
                        break;
                }
            }
            k++;
        }
    }
    myFile.close();
    std::cout << EKGData;
    return 0;
}